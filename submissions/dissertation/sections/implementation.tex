\section{Implementation}

\label{sec:implementation}

As discussed, we have currently implemented both stages of the mechanism but
are yet to tune the parameters required to achieve the truth-telling behaviour
we desire. The system comprises four independent parts, each implementing a
separate area of functionality, as follows:

\begin{enumerate}
	\itemsep0em
	\item Database
	\item Trading
	\item Arbitration
	\item Server
\end{enumerate}

\subsection{Database}

The database is implemented using the Mito library provided by Quicklisp. This
is an object relational mapper that provides support for MySQL, PostgreSQL, and
SQLite3. We can therefore define and interact with tables while staying
completely within the Lisp ecosystem, leading to a quicker and more flexible
development cycle.

We use three tables: \code{USER}, which stores all users in the system and
their remaining budget; \code{SECURITY}, which stores the wager, deadline,
number of shares, and outcome of every user-created security; and
\code{USER-SECURITY}, which is responsible for the many-to-many relationship
between users and securities (i.e., each user may own shares in many
securities). The latter allows us to store a user's position within a market as
well as how they report on it during the arbitration stage, if they indeed
decide to do so. The tables contain the following columns:

\begin{table}[ht]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{User} & Name & Budget \\ \hline
	\end{tabular} \\~\\

	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\textbf{Security} & Bet & Shares & Deadline & Outcome \\ \hline
	\end{tabular} \\~\\

	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		\textbf{User-security} & User & Security & Shares & Report & Positive Belief & Negative Belief \\ \hline
	\end{tabular} \\~\\
\end{table}

An entry in the \code{USER} table consists of a username and a budget. There is
currently no requirement to enter a password to log in to the system -- this
has been done to speed up the testing process, and will be an easy addition in
the future.

The columns in the \code{SECURITY} table contain all information to define a
market in which users may trade: ``bet'' holds the wager that is being
proposed, ``shares'' holds the number of shares which have been bought and
sold, ``deadline'' holds the earliest date-time by which users can receive a
signal on the wager's outcome, and ``outcome'' holds the payout price per share
of the market, to pay out stakeholders.

An entry in the \code{USER-SECURITY} table stores the relationship between
users and securities, whether this is the number of shares a user holds in a
security, an arbiter's report on a security, or both. The ``user'' column
holds the user ID, ``security'' holds the security ID, and the number of shares
owned and their report (or NULL) are stored in the corresponding columns. The
columns ``positive belief'' and ``negative belief'' store a user's estimations
that, given they the event has a positive (respectively negative) outcome, they
receive a positive signal. The manner in which this is used is detailed in
Section~\ref{sec:arbitration}.

Defining such tables using Mito is as simple as using the \code{deftable}
macro, and is syntactically similar to defining a regular struct within Common
Lisp. Listing~\ref{lst:deftable} shows how we define the columns and their
associated datatypes. The macro defines default accessors\footnote{Functions
for accessing members of a struct.}, the slots \code{created\_at},
\code{updated\_at}, and a primary key \code{id} if none is specified. Insertion
is similarly straightforward: to insert a new entry into a table we create an
instance of the class that is implicitly defined when calling \code{deftable},
then call \code{create-dao}. To retrieve records from the database we use
either \code{select-dao}, which returns all records matching the conditions, or
\code{find-dao}, which returns only the first.

\begin{lstlisting}[
	label={lst:deftable},
	language=lisp,
	captionpos=b,
	caption={Defining a table in Mito}]
(deftable security ()
    ((bet :col-type :text)
     (shares :initform 0
             :col-type :integer)
     (deadline :col-type :datetime)
     (outcome :col-type (or :double :null))))
\end{lstlisting}

\subsection{Trading}

Trading allows users to create arbitrary bets on binary events and then trade
shares in them. It also implements the trading fees on risk transactions
required to raise funds to reward arbiters and pay out stakeholders. To
calculate the trading fee, we first need to know whether the user is increasing
their risk (a ``risk transaction'') or they are simply liquidating a position
they already hold, and secondly whether they are buying or selling shares,
since these incur different charges.

To create markets, quote their share prices, and compute the cost of a
transaction we use a market scoring rule. We use the commonly used Logarithmic
Market Scoring Rule (LMSR), created by Robin Hanson~\cite{LMSR}. As we have
mentioned, in any MSR an agent wishing to purchase $q'-q$ shares of a given
security must pay $C(q')-C(q)$ for convex, differentiable, monotonically
increasing function $C$. In the case of LMSR, for current number of shares $q$
and liquidity parameter $b$, this function is:

\begin{equation}
	\label{eq:LMSR}
	C_b(q) = b \log (1 + e^{q/b})
\end{equation}

This function also accommodates selling shares, in which case $q'<q$.  Since a
user must specify a desired amount of shares to buy or sell before we can
determine how much to charge them, we cannot use this function to directly
quote a share price. Instead, we can calculate the cost of the transaction were
the user to purchase a miniscule quantity of shares and quote this as the share
price. This is simply the derivative of Equation~\ref{eq:LMSR} and is given by:

\begin{equation}
	\label{eq:LMSRprice}
	p_b(q) = \frac{ e^{q/b} }{ 1 + e^{q/b} }
\end{equation}

Although Equation~\ref{eq:LMSRprice} quotes the share price, it is not accurate
to use it to calculate how much an agent should pay, since the agent's
participation in the market will immediately change this price. It does,
however, provide a useful means of describing to the user the perceived
likelihood of the event. For example for some security, at $q=0$ an equal
number of shares have been bought as have been sold, meaning the userbase as a
whole is equally unsure about whether the market will have a positive or
negative outcome. The quoted share price will be $p(0)=\$0.50$.  Similarly,
suppose $b=10$ and $q=20$, meaning twenty more shares have been bought than
sold in the market. This would yield a share price of $p_{10}(20) \approx
\$0.88$. Users feel more confident that the event will have a positive outcome,
since more people have bought shares, giving a higher share price. As mentioned
in Section~\ref{sec:oneOverPrior}, we interpret the closing price of the market
as the probability of a positive outcome, as it approximates how sure users
feel about the event's outcome.

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\textwidth]{market-creation}
	\caption{Creating a market for the wager, ``The weather will be hot on
	Friday''}
	\label{fig:marketCreation}
\end{figure}

\subsection{Arbitration}

\label{sec:arbitration}

The arbitration stage of the mechanism seeks to resolve markets whose deadlines
have passed by gathering reports from arbiters and paying out, or demanding
money from, stakeholders. Since we will eventually be able to accommodate for
users to act as arbiters in market in which they themselves hold a position, we
allow any user to opt in to become an arbiter in an unresolved market.
Figure~\ref{fig:dashboard} shows the dashboard as it appears to a logged in
user, in which they are presented with all the currently active and unresolved
markets. 

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\textwidth]{dashboard}
	\caption{A user's dashboard, where they can see all active and unresolved
	markets}
	\label{fig:dashboard}
\end{figure}

Once the user has opted in to arbitration they are taken to a form to submit
their report on the outcome, as well as estimations on their ``Positive
Belief'' and ``Negative Belief''. These are estimations of probabilities that,
given that the event \emph{actually} had a positive (respectively negative)
outcome, the user received a positive signal. This is important as we need to
take into account signal noise, given that wagers can be subjective: while the
positive and negative signal beliefs will be nearer to 1 and 0, respectively,
for an event such as the winner of a football match, since it will likely be
covered by many media outlets all reporting the true result, this may not
necessarily be the case where the outcome is more a matter of opinion. The
weakness of this approach is discussed in Section~\ref{sec:evaluation}.

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\textwidth]{arbitration}
	\caption{The interface for submitting a report as an arbiter}
	\label{fig:resolveSecurity}
\end{figure}

These signal beliefs are used to compute the update probabilities $\mu_1$ and
$\mu_0$ which are used in the 1/prior-with-midpoint mechanism. Given the
closing price $\mu$ and the positive and negative signal beliefs
$Pr[x_i=1|X=1]$ and $Pr[x_i=1|X=0]$ for each arbiter $i$, we can compute the
positive update $\mu_1^i$ for each $i$ and randomly chosen $j$ as follows:

\begin{equation}
	\begin{aligned}
		\mu_1^i & = Pr[x_j=1|x_i=1] \\
		& = Pr[x_j=1|X=0] \cdot Pr[X=0|x_i=1] + Pr[x_j=1|X=1] \cdot Pr[X=1|x_i=1]
	\end{aligned}
\end{equation}

We use the same approach to compute the negative update $\mu_0^i$ for each $i$,
and hence we may now also compute the common updates $\mu_1$ and $\mu_0$ to pay
arbiters the correct reward for arbitration. Once done, we set the outcome of
the market to the fraction of arbiters that reported a positive outcome, paying
users who hold shares and taking money from users that sold shares short.

\subsection{Server}

The code contained in \code{server.lisp} is responsible both for setting up and
maintaining the Hunchentoot web server and defining the various pages and forms
with which users interact.  Hunchentoot makes interaction with the web server
straightforward. We initialise the server by creating an \code{easy-acceptor},
and once we have defined our webpages using CL-WHO we simply push them to the
dispatch table using \code{create-prefix-dispatcher} so that they may be
accessed. Hunchentoot also provides us with automatic session handling, meaning
we do not have to worry about the details of logging in users on different
machines at the same time: we simply define the symbol \code{session-user} in
the appropriate session-handling data structure, then set this to the logged in
user. We can then access this using \code{(session-value 'session-user)} to
display different material on the page and interact with the database according
to the current user. Finally, we use Hunchentoot to access the GET and POST
parameters users send to the server via forms with a call to the library's
\code{parameter} function. 

Although there is little special to CL-WHO compared to other HTML-generating
libraries, it is useful to remain in the Lisp environment to define webpages
since we may use its powerful macro system. We use it to define a template for
a standard page, meaning we only need to specify the elements that make the
page unique and giving the web application a consistent style. This also
enables us to define pages and add the corresponding HTML generating function
to the dispatch table all within a single interface, hiding the unnecessary
details. Listing~\ref{lst:defineURL} shows how we are able to define both the
webpage, generate its content, and push it to the dispatch table in one.

The code in \code{server.lisp} draws together the interfaces from other areas
of the system and actually executes the mechanism. This involves taking user
input to create custom markets, quote share prices, and collect and distribute
payments for the various interactions users may have with the market.

\begin{lstlisting}[
	label={lst:defineURL},
	language=lisp,
	captionpos=b,
	caption={Defining webpages}]
(defmacro define-url-fn ((name) &body body)
  `(progn
     (defun ,name () ,@body)
     (push (create-prefix-dispatcher ,(format NIL "/~(~a~)" name) ',name)
           *dispatch-table*)))
\end{lstlisting}


